import re

# Regular expression generated by ChatGPT
pattern = r"""
    (\[+)|                                # Case 1: Sequential opening brackets
    (\]+)|                                # Case 2: Sequential closing brackets
    ((?:-?\d*\.?\d*(?:[+-]?\d*\.?\d*)j|   # Case 3: Complex floating
      -?\d+\.?\d*|                        #         Number (integer or float)
      -?\.\d+|                            #         Decimal without leading digit
      -?\d+\.\d+[eE][+-]?\d+|             #         Scientific notation
      -?\d+[eE][+-]?\d+|                  #         Integer in scientific notation
      -?inf|nan|True|False)               #         Boolean, NaN, or inf
      \s*(?=\s|,|\)|\]))|                 # Followed by whitespace, comma, or bracket
    (\.{3})                               # Case 4: ellipses
"""

pattern = re.compile(pattern, re.VERBOSE)

def _mask_string(text, mask):
    if not mask.size:  # no masked elements
        return text

    out = []  # store the output string
    index = [0] * mask.ndim  # index of the current element
    dim = -1  # keep track of which dimension of index we're incrementing
    while(text):
        match = pattern.search(text)

        if not match:
            out.append(text)
            break

        before = text[:match.start()]
        match_text = match.group(0)
        text = text[match.end():]

        if match.group(1):  # opening brackets
            # just increment `dim`
            dim += len(match_text)
        elif match.group(2):  # closing brackets
            # decrement `dim` and update all affected indices
            match_length = len(match_text)
            dim -= match_length
            if match_length < len(index):
                index[dim] += 1  # -1 - match_length
                index[dim+1:] = [0]*match_length  # -match_length
        elif match.group(3):  # value
            # replace string of masked element
            match_length = len(match_text)
            if mask[tuple(index)]:
                match_text = " "*(match_length - 1) + "_"
            if mask.ndim:  # special case for 0-d array
                index[-1] += 1
        elif match.group(4):  # ellipses
            # assumes there are equal number of elements
            # (e.g. values, rows) before and after ellipses
            index[dim] *= -1

        out.append(before)
        out.append(match_text)
        # Assumes first capture group is beginning brackets, which
        # will make dim >= 0. We want to exit early so array metadata
        # (e.g. "shape=(2, 3, 1000)") isn't processed
        if dim == -1:
            out.append(text)
            break

    return "".join(out)
